<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yo Store - Магазин электроники</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .logo {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            object-fit: cover;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .search-bar {
            background: white;
            border-radius: 25px;
            padding: 15px 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .search-input {
            width: 100%;
            border: none;
            outline: none;
            font-size: 1.1rem;
            background: transparent;
        }
        
        .categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .category-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .category-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        /* Стили для подкатегорий */
        .subcategories {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        
        .subcategory-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }
        
        .subcategory-item:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }
        
        .subcategory-icon {
            margin-right: 8px;
            font-size: 1.1em;
        }
        
        .subcategory-name {
            flex: 1;
            font-weight: 500;
        }
        
        .subcategory-count {
            font-size: 0.8em;
            opacity: 0.8;
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        /* Стили для хлебных крошек */
        .breadcrumbs {
            margin: 8px 0 12px 0;
            padding: 6px 12px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            box-shadow: 0 1px 4px rgba(0,0,0,0.03);
        }
        
        .breadcrumb-trail {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 4px;
            font-size: 11px;
            color: #6c757d;
            opacity: 0.8;
        }
        
        .breadcrumb-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .breadcrumb-link {
            color: #667eea;
            text-decoration: none;
            padding: 2px 4px;
            border-radius: 2px;
            transition: all 0.2s ease;
            font-size: 11px;
        }
        
        .breadcrumb-link:hover {
            background: #667eea;
            color: white;
            opacity: 1;
        }
        
        .breadcrumb-current {
            color: #495057;
            font-weight: 400;
            padding: 2px 4px;
            background: transparent;
            border-radius: 2px;
            font-size: 11px;
        }
        
        .breadcrumb-separator {
            color: #adb5bd;
            margin: 0 2px;
            font-size: 10px;
            opacity: 0.6;
        }
        
        .category-header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1rem;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            border-radius: 15px;
            color: #333;
        }
        
        .category-header h2 {
            margin: 0;
            font-size: 1.8rem;
            font-weight: 600;
        }
        
        .category-header p {
            margin: 8px 0 0 0;
            opacity: 0.9;
            font-size: 1rem;
        }
        
        .subcategories-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            padding: 1rem 0;
        }
        
        .subcategory-card {
            background: white;
            border-radius: 15px;
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            border: 2px solid transparent;
        }
        
        .subcategory-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            border-color: #667eea;
        }
        
        .subcategory-card .subcategory-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            display: block;
        }
        
        .subcategory-card .subcategory-name {
            font-size: 1.2rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 0.5rem;
        }
        
        .subcategory-card .subcategory-count {
            font-size: 0.9rem;
            color: #666;
            background: #f8f9fa;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            display: inline-block;
        }
        
        .product-description-spoiler, .product-specifications-spoiler {
            margin: 10px 0;
        }
        
        .spoiler-header {
            cursor: pointer;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
        }
        
        .spoiler-header:hover {
            background-color: #f8f9fa;
            border-radius: 5px;
            padding: 8px 10px;
            margin: 0 -10px;
        }
        
        .spoiler-title {
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }
        
        .spoiler-arrow {
            color: #667eea;
            font-size: 0.8rem;
            transition: transform 0.2s ease;
        }
        
        .spoiler-content {
            padding: 10px 0;
            margin-top: 5px;
        }
        
        .product-description {
            font-size: 0.9rem;
            color: #666;
            line-height: 1.4;
        }
        
        .specifications {
            font-size: 0.9rem;
        }
        
        .spec-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .spec-key {
            font-weight: 600;
            color: #333;
        }
        
        .spec-value {
            color: #666;
            text-align: right;
            max-width: 60%;
        }
        
        .product-variants {
            margin: 12px 0;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }
        
        .variant-group {
            margin-bottom: 8px;
        }
        
        .variant-group:last-child {
            margin-bottom: 0;
        }
        
        .variant-group label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }
        
        .variant-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .variant-btn {
            padding: 5px 10px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 18px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            min-width: 50px;
            text-align: center;
        }
        
        .variant-btn:hover {
            border-color: #667eea;
            background: #f0f3ff;
        }
        
        .variant-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
            font-weight: 600;
        }
        
        .variant-btn.active:hover {
            background: #5a67d8;
            border-color: #5a67d8;
        }
        
        /* Special styles for color buttons */
        .color-btn {
            position: relative;
            overflow: hidden;
            border: 2px solid;
            font-weight: 600;
            text-shadow: 0px 0px 2px rgba(0,0,0,0.3);
            min-width: 70px;
            padding: 6px 12px;
        }
        
        .color-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 50%);
            pointer-events: none;
        }
        
        .color-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            filter: brightness(1.1);
        }
        
        .color-btn.active {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            filter: brightness(1.2);
        }
        
        
        /* Стили для групп вариантов */
        .variant-group {
            margin: 15px 0;
        }
        
        .variant-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        
        /* Стили для кнопок памяти и SIM */
        .memory-btn, .sim-btn {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            color: #495057;
        }
        
        .memory-btn:hover, .sim-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .memory-btn.active, .sim-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
            font-weight: 600;
        }
        
        .category-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .category-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }
        
        .category-count {
            font-size: 0.9rem;
            color: #666;
        }
        
        .products-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }
        
        /* Стили для иерархических фильтров */
        .hierarchy-filters {
            margin: 15px 0;
            padding: 12px 20px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }
        
        .hierarchy-filter-section {
            margin-bottom: 6px;
        }
        
        .filter-group {
            margin-bottom: 8px;
        }
        
        .filter-group h4 {
            margin: 0 0 6px 0;
            font-size: 13px;
            font-weight: 600;
            color: #495057;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .filter-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .filter-btn {
            padding: 8px 16px;
            background: #ffffff;
            border: 2px solid #dee2e6;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            color: #495057;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        
        .filter-btn:hover {
            background: #007bff;
            border-color: #007bff;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,123,255,0.3);
        }
        
        .filter-btn.active {
            background: #007bff;
            border-color: #007bff;
            color: white;
            box-shadow: 0 2px 8px rgba(0,123,255,0.4);
        }
        
        .filter-reset {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #dee2e6;
        }
        
        .reset-btn {
            padding: 6px 12px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .reset-btn:hover {
            background: #c82333;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(220,53,69,0.2);
        }
        
        /* Стили для индикатора загрузки товаров */
        .loading-products {
            text-align: center;
            padding: 40px 20px;
            color: #007bff;
            font-size: 16px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
            animation: pulse 1.5s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            from { opacity: 0.6; }
            to { opacity: 1; }
        }
        
        .product-card {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .product-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        .product-image {
            width: 100%;
            height: 300px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            color: #999;
        }
        
        .product-info {
            padding: 20px;
        }
        
        .product-name {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }
        
        .product-brand {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        
        .product-price {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .current-price {
            font-size: 1.4rem;
            font-weight: 700;
            color: #e74c3c;
        }
        
        .old-price {
            font-size: 1rem;
            color: #999;
            text-decoration: line-through;
        }
        
        .discount {
            background: #e74c3c;
            color: #333;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .product-description {
            color: #666;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #333;
            font-size: 1.2rem;
        }
        
        .error {
            text-align: center;
            padding: 40px;
            color: #333;
            background: rgba(231, 76, 60, 0.1);
            border-radius: 15px;
            margin: 20px 0;
        }
        
        .no-products {
            text-align: center;
            padding: 40px;
            color: #333;
            font-size: 1.1rem;
        }
        
        .back-button {
            background: white;
            border: none;
            border-radius: 20px;
            padding: 6px 12px;
            margin-bottom: 12px;
            cursor: pointer;
            font-weight: 400;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        /* Стили для карусели изображений */
        .product-image-carousel {
            position: relative;
            width: 100%;
            height: 300px;
            overflow: hidden;
            border-radius: 15px;
            padding: 5%;
            box-sizing: border-box;
            background: white;
        }
        
        .product-image-carousel .product-img {
            width: 100%;
            height: 100%;
            margin: 0;
            object-fit: contain;
            border-radius: 10px;
        }
        
        .product-img {
            width: 90%;
            height: 90%;
            object-fit: contain;
            border-radius: 15px;
            margin: 5%;
        }
        
        .image-placeholder {
            width: 90%;
            height: 90%;
            margin: 5%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            background: #f0f0f0;
            border-radius: 15px;
        }
        
        .image-indicators {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
        }
        
        .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .indicator.active {
            background: white;
        }
        
        .image-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.5);
            color: #333;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .product-image-carousel:hover .image-nav {
            opacity: 1;
        }
        
        .image-nav.prev {
            left: 10px;
        }
        
        .image-nav.next {
            right: 10px;
        }
        
        /* Стили для детального просмотра товара */
        .product-details {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .product-details-header {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .product-details-image {
            flex: 0 0 300px;
        }
        
        .details-img {
            width: 100%;
            height: 300px;
            object-fit: cover;
            border-radius: 15px;
        }
        
        .details-placeholder {
            width: 100%;
            height: 300px;
            background: #f5f5f5;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
        }
        
        .product-details-info {
            flex: 1;
        }
        
        .product-details-name {
            font-size: 2.5em;
            font-weight: bold;
            color: #333;
            margin: 0 0 10px 0;
        }
        
        .product-details-brand {
            font-size: 1.2em;
            color: #666;
            margin-bottom: 20px;
        }
        
        .product-details-price {
            margin-bottom: 15px;
        }
        
        .product-details-sku {
            font-size: 0.9em;
            color: #888;
            font-family: monospace;
        }
        
        .product-details-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .product-description-section,
        .product-specifications-section {
            margin-bottom: 30px;
        }
        
        .product-description-section h3,
        .product-specifications-section h3 {
            font-size: 1.5em;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #007AFF;
        }
        
        .product-full-description {
            line-height: 1.6;
            color: #555;
            font-size: 1.1em;
        }
        
        .specifications-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .spec-category {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #007AFF;
        }
        
        .spec-category h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.2em;
            text-transform: capitalize;
        }
        
        .spec-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
        }
        
        .spec-key {
            font-weight: 600;
            color: #555;
            flex: 0 0 40%;
        }
        
        .spec-value {
            color: #333;
            flex: 1;
            text-align: right;
        }
        
        .product-actions {
            display: flex;
            gap: 15px;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        
        .buy-button,
        .favorite-button {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .buy-button {
            background: #007AFF;
            color: #333;
            flex: 1;
        }
        
        .buy-button:hover {
            background: #0056CC;
            transform: translateY(-2px);
        }
        
        .favorite-button {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #ddd;
        }
        
        .favorite-button:hover {
            background: #e9ecef;
            border-color: #007AFF;
        }
        
        @media (max-width: 768px) {
            .product-details-header {
                flex-direction: column;
            }
            
            .product-details-image {
                flex: none;
            }
            
            .product-details-name {
                font-size: 2em;
            }
            
            .specifications-grid {
                grid-template-columns: 1fr;
            }
            
            .product-actions {
                flex-direction: column;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .logo {
                width: 40px;
                height: 40px;
            }
            
            .categories {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }
            
            .products-grid {
                grid-template-columns: 1fr;
            }
            
            .product-image {
                height: 250px;
            }
            
            .product-image-carousel {
                height: 250px;
            }
            
            .product-img {
                width: 92%;
                height: 92%;
                margin: 4%;
            }
        }
        
        @media (max-width: 480px) {
            .product-image {
                height: 220px;
            }
            
            .product-image-carousel {
                height: 220px;
            }
            
            .product-img {
                width: 94%;
                height: 94%;
                margin: 3%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <img src="/static/images/logo.jpg" alt="Yo Store" class="logo">
                Yo Store
            </h1>
            <p>Лучшие цены на технику • Доставка по всей России</p>
        </div>
        
        <div class="search-bar">
            <input type="text" class="search-input" placeholder="🔍 Поиск товаров..." id="searchInput">
        </div>
        
        <div id="content">
            <div class="loading">Подождите, идет загрузка...</div>
        </div>
    </div>

    <script>
        const API_BASE = window.location.origin;
        let currentView = 'categories';
        
        // Глобальные переменные для фильтрации
        let currentBrandFilter = null;
        let currentLevel0Filter = null;
        let currentLevel1Filter = null;
        let currentLevel2Filter = null;
        let currentCategoryId = null; // Сохраняем ID текущей категории
        let currentCategoryName = null; // Сохраняем название текущей категории
        
        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, starting initialization...');
            
            // Тест что JavaScript работает
            setTimeout(() => {
                console.log('JavaScript is working - DOM fully loaded');
                const content = document.getElementById('content');
                if (content) {
                    console.log('Content element found:', content);
                } else {
                    console.error('Content element not found!');
                }
            }, 1000);
            
            try {
                loadCategories();
                setupSearch();
                
                // Таймаут на случай если загрузка застряла
                setTimeout(() => {
                    const content = document.getElementById('content');
                    if (content.textContent.includes('загрузка')) {
                        console.error('Loading timeout - forcing reload');
                        showError('Время загрузки истекло. Попробуйте обновить страницу.');
                    }
                }, 10000); // 10 секунд
                
            } catch (error) {
                console.error('Initialization error:', error);
                showError('Ошибка инициализации приложения: ' + error.message);
            }
        });
        
        // Setup search functionality
        function setupSearch() {
            const searchInput = document.getElementById('searchInput');
            let searchTimeout;
            
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    const query = this.value.trim();
                    if (query.length > 2) {
                        searchProducts(query);
                    } else if (query.length === 0 && currentView === 'search') {
                        loadCategories();
                    }
                }, 500);
            });
        }
        
        // Load categories
        async function loadCategories() {
            try {
                console.log('Starting loadCategories...');
                showLoading();
                console.log('Fetching categories from:', `${API_BASE}/categories`);
                const response = await fetch(`${API_BASE}/categories`);
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const categories = await response.json();
                console.log('Categories loaded:', categories.length);
                
                currentView = 'categories';
                currentCategoryId = null;
                
                console.log('Creating categories HTML...');
                const content = document.getElementById('content');
                
                // Упрощенная версия для отладки
                let categoriesHtml = '<div class="categories">';
                
                for (let i = 0; i < categories.length; i++) {
                    const category = categories[i];
                    console.log(`Processing category ${i}: ${category.name}`);
                    
                    categoriesHtml += `
                        <div class="category-card" onclick="loadSubcategories(${category.id})">
                            <div class="category-icon">${category.icon}</div>
                            <div class="category-name">${category.name}</div>
                            <div class="category-count">${category.product_count} товаров</div>
                    `;
                    
                    // Добавляем подкатегории если есть
                    if (category.subcategories && category.subcategories.length > 0) {
                        categoriesHtml += '<div class="subcategories">';
                        for (let j = 0; j < category.subcategories.length; j++) {
                            const subcat = category.subcategories[j];
                            categoriesHtml += `
                                <div class="subcategory-item" onclick="event.stopPropagation(); loadProductsByBrandWithCategory('${subcat.brand}', ${category.id}, '${category.name}')">
                                    <span class="subcategory-icon">${subcat.icon}</span>
                                    <span class="subcategory-name">${subcat.brand}</span>
                                    <span class="subcategory-count">${subcat.product_count}</span>
                                </div>
                            `;
                        }
                        categoriesHtml += '</div>';
                    }
                    categoriesHtml += '</div>';
                }
                categoriesHtml += '</div>';
                
                content.innerHTML = categoriesHtml;
                console.log('Categories HTML generated and displayed');
                
                // Добавить небольшую задержку для визуального эффекта
                setTimeout(() => {
                    console.log('Categories initialization complete');
                }, 100);
                
            } catch (error) {
                console.error('Error loading categories:', error);
                showError('Ошибка загрузки категорий: ' + error.message);
            }
        }
        
        // Load subcategories for category
        async function loadSubcategories(categoryId) {
            try {
                showLoading();
                const response = await fetch(`${API_BASE}/categories`);
                const categories = await response.json();
                
                // Найти нужную категорию
                const category = categories.find(cat => cat.id === categoryId);
                if (!category || !category.subcategories || category.subcategories.length === 0) {
                    showError('Подкатегории не найдены');
                    return;
                }
                
                currentView = 'subcategories';
                currentCategoryId = categoryId;
                
                const content = document.getElementById('content');
                content.innerHTML = `
                    <button class="back-button" onclick="loadCategories()">← Назад к категориям</button>
                    <div class="category-header">
                        <h2>${category.icon} ${category.name}</h2>
                        <p>Выберите бренд для просмотра товаров</p>
                    </div>
                    <div class="subcategories-grid">
                        ${category.subcategories.map(subcat => `
                            <div class="subcategory-card" onclick="loadProductsByBrandWithCategory('${subcat.brand}', ${categoryId}, '${category.name}')">
                                <div class="subcategory-icon">${subcat.icon}</div>
                                <div class="subcategory-name">${subcat.brand}</div>
                                <div class="subcategory-count">${subcat.product_count} товаров</div>
                            </div>
                        `).join('')}
                    </div>
                `;
            } catch (error) {
                showError('Ошибка загрузки подкатегорий');
            }
        }
        
        // Load products for category (all products in category and subcategories)
        async function loadProducts(categoryId) {
            try {
                showLoading();
                const response = await fetch(`${API_BASE}/products?category_id=${categoryId}&limit=20`);
                const products = await response.json();
                
                currentView = 'products';
                currentCategoryId = categoryId;
                
                const content = document.getElementById('content');
                content.innerHTML = `
                    <button class="back-button" onclick="loadCategories()">← Назад к категориям</button>
                    <div class="products-grid">
                        ${products.map(product => {
                            storeProductImages(product);
                            return createProductCard(product);
                        }).join('')}
                    </div>
                `;
                
                // Инициализировать цвета по умолчанию после рендеринга
                setTimeout(() => {
                    initializeDefaultColors();
                }, 100);
            } catch (error) {
                showError('Ошибка загрузки товаров');
            }
        }
        
        // Load products by brand with hierarchical filters
        async function loadProductsByBrand(brand, categoryId) {
            try {
                showLoading();
                
                // Сохраняем текущий фильтр бренда
                currentBrandFilter = brand;
                // Не сбрасываем currentLevel0Filter - он уже определен из категории
                currentLevel1Filter = null;
                currentLevel2Filter = null;
                
                // Получаем товары с учетом уровня категории (level0) если он уже определен
                let url = `${API_BASE}/products?brand=${encodeURIComponent(brand)}&limit=50`;
                if (currentLevel0Filter) {
                    url += `&level0=${encodeURIComponent(currentLevel0Filter)}`;
                    console.log(`🔗 Запрашиваем товары с URL: ${url}`);
                } else {
                    console.log(`🔗 Запрашиваем товары без level0 фильтра: ${url}`);
                }
                
                const response = await fetch(url);
                const products = await response.json();
                console.log(`📦 Получено товаров: ${products.length}`);
                if (products.length > 0) {
                    console.log(`📋 Первый товар: ${products[0].name} (level0: ${products[0].level0})`);
                }
                
                // Определяем level0 из контекста категории или первого товара ТОЛЬКО если еще не определен
                if (!currentLevel0Filter && products.length > 0) {
                    currentLevel0Filter = products[0].level0 || products[0].category_name.split(' / ')[0];
                }
                
                currentView = 'brand_products';
                currentCategoryId = categoryId;
                
                const content = document.getElementById('content');
                content.innerHTML = `
                    <button class="back-button" onclick="loadCategories()">← Назад к категориям</button>
                    <div class="breadcrumbs" id="breadcrumbsContainer">
                        ${createBreadcrumbs(brand)}
                    </div>
                    <div class="hierarchy-filters" id="hierarchyFilters">
                        <!-- Фильтры будут добавлены динамически -->
                    </div>
                    <div class="products-grid">
                        ${products.map(product => {
                            storeProductImages(product);
                            return createProductCard(product);
                        }).join('')}
                    </div>
                `;
                
                // Создаем кнопки фильтрации level1
                await createHierarchyFilters(brand, products);
                
                // Инициализировать цвета по умолчанию после рендеринга
                setTimeout(() => {
                    initializeDefaultColors();
                }, 100);
            } catch (error) {
                showError('Ошибка загрузки товаров бренда');
            }
        }
        
        // Search products
        async function searchProducts(query) {
            try {
                showLoading();
                const response = await fetch(`${API_BASE}/search?q=${encodeURIComponent(query)}&limit=20`);
                const products = await response.json();
                
                currentView = 'search';
                currentCategoryId = null;
                
                const content = document.getElementById('content');
                if (products.length === 0) {
                    content.innerHTML = `
                        <div class="no-products">
                            По запросу "${query}" ничего не найдено
                        </div>
                    `;
                } else {
                    content.innerHTML = `
                        <button class="back-button" onclick="loadCategories()">← Назад к категориям</button>
                        <div class="products-grid">
                            ${products.map(product => {
                                storeProductImages(product);
                                return createProductCard(product);
                            }).join('')}
                        </div>
                    `;
                    
                    // Инициализировать цвета по умолчанию после рендеринга
                    setTimeout(() => {
                        initializeDefaultColors();
                    }, 100);
                }
            } catch (error) {
                showError('Ошибка поиска');
            }
        }
        
        // Загрузка товаров бренда с учетом категории
        async function loadProductsByBrandWithCategory(brand, categoryId, categoryName) {
            console.log(`🎯 Загружаем товары бренда ${brand} в категории ${categoryName}`);
            // Устанавливаем level0Filter на основе названия категории
            currentLevel0Filter = categoryName;
            currentCategoryId = categoryId;
            currentCategoryName = categoryName;
            console.log(`📝 Установлены фильтры: level0=${currentLevel0Filter}, categoryId=${currentCategoryId}`);
            // Вызываем основную функцию
            await loadProductsByBrand(brand, categoryId);
        }
        
        // Создание фильтров иерархии
        async function createHierarchyFilters(brand, products) {
            try {
                console.log(`🏗️ Создаем фильтры для бренда ${brand}, currentLevel0Filter: ${currentLevel0Filter}`);
                
                const filtersContainer = document.getElementById('hierarchyFilters');
                if (!filtersContainer) return;
                
                // Если level0 еще не определен, определяем его из товаров (первая категория)
                if (!currentLevel0Filter && products.length > 0) {
                    const firstProductLevel0 = products[0].level0 || products[0].category_name.split(' / ')[0];
                    currentLevel0Filter = firstProductLevel0;
                    console.log(`🔍 Автоопределен level0 из товаров: ${currentLevel0Filter}`);
                }
                
                let filtersHtml = '<div class="hierarchy-filter-section">';
                
                // Level1 фильтры (начинаем сразу с уровня 1, так как level0 уже выбран ранее)
                let level1Values = [];
                if (currentLevel0Filter) {
                    const level1Url = `${API_BASE}/hierarchy/levels?level=1&brand=${encodeURIComponent(brand)}&parent_level0=${encodeURIComponent(currentLevel0Filter)}`;
                    console.log(`🔗 Запрашиваем level1 для ${brand} в ${currentLevel0Filter}: ${level1Url}`);
                    
                    const level1Response = await fetch(level1Url);
                    level1Values = await level1Response.json();
                    console.log(`📋 Получены level1 значения:`, level1Values);
                }
                
                if (level1Values.length > 0) {
                    filtersHtml += `
                        <div class="filter-group">
                            <h4>Серия:</h4>
                            <div class="filter-buttons">
                                ${level1Values.map(level1 => 
                                    `<button class="filter-btn ${currentLevel1Filter === level1 ? 'active' : ''}" 
                                             onclick="applyLevelFilter('level1', '${level1}')">
                                        ${level1}
                                    </button>`
                                ).join('')}
                            </div>
                        </div>
                    `;
                }
                
                // Level2 фильтры (показываем только если выбран level1)
                if (currentLevel1Filter) {
                    const level2Response = await fetch(`${API_BASE}/hierarchy/levels?level=2&brand=${encodeURIComponent(brand)}&parent_level1=${encodeURIComponent(currentLevel1Filter)}`);
                    const level2Values = await level2Response.json();
                    
                    if (level2Values.length > 0) {
                        filtersHtml += `
                            <div class="filter-group">
                                <h4>Модель:</h4>
                                <div class="filter-buttons">
                                    ${level2Values.map(level2 => 
                                        `<button class="filter-btn ${currentLevel2Filter === level2 ? 'active' : ''}" 
                                                 onclick="applyLevelFilter('level2', '${level2}')">
                                            ${level2}
                                        </button>`
                                    ).join('')}
                                </div>
                            </div>
                        `;
                    }
                }
                
                filtersHtml += '</div>';
                
                // Кнопка сброса фильтров
                if (currentLevel1Filter || currentLevel2Filter) {
                    filtersHtml += `
                        <div class="filter-reset">
                            <button class="reset-btn" onclick="resetFilters()">Сбросить фильтры</button>
                        </div>
                    `;
                }
                
                filtersContainer.innerHTML = filtersHtml;
                
            } catch (error) {
                console.error('Ошибка создания фильтров:', error);
            }
        }
        
        // Применение фильтра по уровням
        async function applyLevelFilter(filterType, filterValue) {
            try {
                // Обновляем глобальные переменные
                if (filterType === 'level0') {
                    currentLevel0Filter = filterValue;
                    currentLevel1Filter = null;
                    currentLevel2Filter = null;
                } else if (filterType === 'level1') {
                    currentLevel1Filter = filterValue;
                    currentLevel2Filter = null;
                } else if (filterType === 'level2') {
                    currentLevel2Filter = filterValue;
                }
                
                // Загружаем отфильтрованные товары
                await loadFilteredProducts();
                
                // Обновляем хлебные крошки
                updateBreadcrumbs();
                
                // Обновляем кнопки фильтров
                await createHierarchyFilters(currentBrandFilter, []);
                
            } catch (error) {
                console.error('Ошибка применения фильтра:', error);
            }
        }
        
        // Загрузка отфильтрованных товаров
        async function loadFilteredProducts() {
            try {
                // Добавить индикатор загрузки только к grid товаров
                const content = document.getElementById('content');
                const productsContainer = content.querySelector('.products-grid');
                
                if (!productsContainer) {
                    console.error('Products container not found');
                    return;
                }
                
                // Показываем спиннер загрузки
                productsContainer.innerHTML = '<div class="loading-products">Обновление товаров...</div>';
                
                // Строим URL с текущими фильтрами
                const params = new URLSearchParams();
                params.append('brand', currentBrandFilter);
                params.append('limit', '50');
                
                if (currentLevel0Filter) params.append('level0', currentLevel0Filter);
                if (currentLevel1Filter) params.append('level1', currentLevel1Filter);
                if (currentLevel2Filter) params.append('level2', currentLevel2Filter);
                
                const response = await fetch(`${API_BASE}/products?${params.toString()}`);
                const products = await response.json();
                
                // Обновляем только товары в grid
                productsContainer.innerHTML = products.map(product => {
                    storeProductImages(product);
                    return createProductCard(product);
                }).join('');
                
                // Инициализировать цвета по умолчанию
                setTimeout(() => {
                    initializeDefaultColors();
                }, 100);
                
            } catch (error) {
                console.error('Ошибка загрузки отфильтрованных товаров:', error);
                const productsContainer = document.querySelector('.products-grid');
                if (productsContainer) {
                    productsContainer.innerHTML = '<div class="error">Ошибка загрузки товаров</div>';
                }
            }
        }
        
        // Сброс всех фильтров
        async function resetFilters() {
            currentLevel1Filter = null;
            currentLevel2Filter = null;
            // НЕ сбрасываем currentLevel0Filter - он должен оставаться из категории
            
            await loadFilteredProducts();
            
            // Обновляем хлебные крошки
            updateBreadcrumbs();
            
            await createHierarchyFilters(currentBrandFilter, []);
        }
        
        // Create product card HTML
        function createProductCard(product) {
            const discountHtml = product.discount_percentage > 0 
                ? `<span class="discount">-${Math.round(product.discount_percentage)}%</span>` 
                : '';
            
            const oldPriceHtml = product.old_price > product.price 
                ? `<span class="old-price">${Math.round(product.old_price).toLocaleString()} ₽</span>` 
                : '';
            
            // Определяем модель для загрузки вариантов
            const modelKey = product.model;
            
            // Создать базовую HTML структуру для вариантов товара
            const variantSelectorsHtml = `
                <div class="product-variants" data-product-id="${product.id}" data-model="${modelKey}">
                    <!-- Варианты будут загружены динамически -->
                    <div class="loading">Загрузка вариантов...</div>
                </div>
            `;
            
            // Обработка изображений
            let imageHtml = '📱'; // Эмодзи по умолчанию
            
            if (product.images && product.images.length > 0) {
                // Если есть множественные изображения
                if (product.images.length > 1) {
                    imageHtml = `
                        <div class="product-image-carousel" data-product-id="${product.id}">
                            <img src="${product.images[0]}" alt="${product.name}" class="product-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div class="image-placeholder" style="display: none;">📱</div>
                            <div class="image-indicators">
                                ${product.images.map((_, index) => 
                                    `<span class="indicator ${index === 0 ? 'active' : ''}" data-index="${index}"></span>`
                                ).join('')}
                            </div>
                            <div class="image-nav prev" onclick="event.stopPropagation(); changeImage(${product.id}, -1)">‹</div>
                            <div class="image-nav next" onclick="event.stopPropagation(); changeImage(${product.id}, 1)">›</div>
                        </div>
                    `;
                } else {
                    // Одно изображение
                    imageHtml = `
                        <img src="${product.images[0]}" alt="${product.name}" class="product-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div class="image-placeholder" style="display: none;">📱</div>
                    `;
                }
            } else if (product.image_url) {
                // Старое поле image_url
                imageHtml = `
                    <img src="${product.image_url}" alt="${product.name}" class="product-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                    <div class="image-placeholder" style="display: none;">📱</div>
                `;
            }
            
            return `
                <div class="product-card">
                    <div class="product-image">
                        ${imageHtml}
                    </div>
                    <div class="product-info">
                        <div class="product-name">${product.name}</div>
                        <div class="product-brand">${product.brand}</div>
                        <div class="product-price">
                            <span class="current-price" id="price-${product.id}">${Math.round(product.price).toLocaleString()} ₽</span>
                            ${oldPriceHtml}
                            ${discountHtml}
                        </div>
                        
                        <!-- Варианты товара -->
                        ${variantSelectorsHtml}
                        
                        <!-- Спойлеры для описания и характеристик -->
                        <div class="product-description-spoiler">
                            <div class="spoiler-header" onclick="toggleSpoiler('desc-${product.id}')">
                                <span class="spoiler-title">Описание</span>
                                <span class="spoiler-arrow" id="arrow-desc-${product.id}">▶</span>
                            </div>
                            <div class="spoiler-content" id="desc-${product.id}" style="display: none;">
                                <div class="product-description">${product.description}</div>
                            </div>
                        </div>
                        
                        <div class="product-specifications-spoiler">
                            <div class="spoiler-header" onclick="toggleSpoiler('spec-${product.id}')">
                                <span class="spoiler-title">Характеристики</span>
                                <span class="spoiler-arrow" id="arrow-spec-${product.id}">▶</span>
                            </div>
                            <div class="spoiler-content" id="spec-${product.id}" style="display: none;">
                                <div class="specifications">
                                    ${product.specifications ? Object.entries(product.specifications)
                                        .filter(([key, value]) => !['variants', 'images', 'image_folder', 'memories', 'colors', 'sim_types', 'цвета'].includes(key))
                                        .map(([key, value]) => 
                                        `<div class="spec-item"><span class="spec-key">${key}:</span> <span class="spec-value">${value}</span></div>`
                                    ).join('') : 'Характеристики не указаны'}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Toggle spoiler content
        function toggleSpoiler(spoilerId) {
            const content = document.getElementById(spoilerId);
            const arrow = document.getElementById('arrow-' + spoilerId);
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.textContent = '▼';
            } else {
                content.style.display = 'none';
                arrow.textContent = '▶';
            }
        }
        
        // Calculate variant price
        function calculateVariantPrice(productId, basePrice, selectedVariant) {
            let priceModifier = 0;
            
            // Логика расчета цены на основе выбранных вариантов
            if (selectedVariant.memory) {
                const memoryPrice = {
                    '128GB': 0,
                    '256GB': 10000,
                    '512GB': 20000,
                    '1TB': 30000
                };
                priceModifier += memoryPrice[selectedVariant.memory] || 0;
            }
            
            if (selectedVariant.color) {
                // Обычно цвет не влияет на цену, но может быть особые цвета
                if (selectedVariant.color.includes('Gold') || selectedVariant.color.includes('Special')) {
                    priceModifier += 5000;
                }
            }
            
            if (selectedVariant.sim) {
                if (selectedVariant.sim === 'Dual SIM') {
                    priceModifier += 2000;
                } else if (selectedVariant.sim === 'eSIM') {
                    priceModifier += 1000;
                }
            }
            
            // Для ноутбуков
            if (selectedVariant.screen) {
                const screenPrice = {
                    '14"': 0,
                    '15"': 15000,
                    '16"': 25000,
                    '17"': 35000
                };
                priceModifier += screenPrice[selectedVariant.screen] || 0;
            }
            
            if (selectedVariant.ram) {
                const ramPrice = {
                    '8GB': 0,
                    '16GB': 10000,
                    '32GB': 25000,
                    '64GB': 50000
                };
                priceModifier += ramPrice[selectedVariant.ram] || 0;
            }
            
            if (selectedVariant.ssd) {
                const ssdPrice = {
                    '256GB': 0,
                    '512GB': 15000,
                    '1TB': 30000,
                    '2TB': 60000
                };
                priceModifier += ssdPrice[selectedVariant.ssd] || 0;
            }
            
            return basePrice + priceModifier;
        }
        
        // Toggle variant button
        function toggleVariant(productId, buttonElement) {
            const productCard = buttonElement.closest('.product-card');
            const variantsContainer = productCard.querySelector('.product-variants');
            const variantType = buttonElement.dataset.type;
            const variantValue = buttonElement.dataset.value;
            
            // Снять активность с других кнопок того же типа
            const sameTypeButtons = variantsContainer.querySelectorAll(`[data-type="${variantType}"]`);
            sameTypeButtons.forEach(btn => btn.classList.remove('active'));
            
            // Активировать выбранную кнопку
            buttonElement.classList.add('active');
            
            // Обновить изображение если выбран цвет
            if (variantType === 'color') {
                updateProductImage(productId, variantValue);
            }
            
            // Получить все выбранные варианты
            const selectedVariants = {};
            const activeButtons = variantsContainer.querySelectorAll('.variant-btn.active');
            activeButtons.forEach(btn => {
                selectedVariants[btn.dataset.type] = btn.dataset.value;
            });
            
            // Получить базовую цену
            const priceElement = productCard.querySelector(`#price-${productId}`);
            const basePriceText = priceElement.textContent.replace(/[^\d]/g, '');
            const basePrice = parseInt(basePriceText) || 0;
            
            // Рассчитать новую цену
            const newPrice = calculateVariantPrice(productId, basePrice, selectedVariants);
            
            // Обновить отображение цены
            priceElement.textContent = `${Math.round(newPrice).toLocaleString()} ₽`;
        }
        
        // Update product image based on selected color - БЕЗ ХАРДКОДА!
        async function updateProductImage(productId, selectedColor) {
            // Валидация входных параметров
            if (!selectedColor || selectedColor === 'undefined' || selectedColor === 'null') {
                console.warn(`❌ Неверный цвет для товара ID ${productId}:`, selectedColor);
                return;
            }
            
            // Найти карточку товара
            const productCard = document.querySelector(`[data-product-id="${productId}"]`)?.closest('.product-card');
            if (!productCard) {
                console.warn(`Карточка товара с ID ${productId} не найдена`);
                return;
            }
            
            // Получить модель товара из data-model атрибута
            const variantsElement = productCard.querySelector('.product-variants');
            if (!variantsElement || !variantsElement.dataset.model) {
                console.warn(`Модель товара не найдена для ID ${productId}`);
                return;
            }
            
            const brandModel = variantsElement.dataset.model; // "Apple iPhone 16 Pro"
            
            // Получить model_key из названия модели
            const modelKey = getModelKey(brandModel);
            if (!modelKey) {
                console.warn(`Не удалось определить model_key для ${brandModel}`);
                return;
            }
            
            // Преобразуем название цвета для API (Cosmic Orange -> cosmic-orange)
            const colorMapping = {
                'Cosmic Orange': 'cosmic-orange',
                'Deep Blue': 'deep-blue',
                'Space Black': 'space-black',
                'Titanium Desert': 'titanium-desert',
                'Titanium Natural': 'titanium-natural',
                'Titanium Black': 'titanium-black',
                'Titanium White': 'titanium-white',
                'Teal': 'teal',
                'Pink': 'pink',
                'White': 'white',
                'Black': 'black',
                'Silver': 'silver'
            };
            
            const colorFolder = colorMapping[selectedColor] || selectedColor.toLowerCase().replace(/\s+/g, '-');
            
            console.log(`📸 Обновляем изображения для ${brandModel} цвета ${selectedColor} -> ${colorFolder} (modelKey: ${modelKey})`);
            
            try {
                // Получить информацию об изображениях из API
                const response = await fetch(`/product-images/${modelKey}/${colorFolder}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const imageData = await response.json();
                
                // Добавить timestamp для предотвращения кэширования
                const timestampedPaths = imageData.image_paths.map(img => `${img}?v=${Date.now()}`);
                
                // Обновить изображения в карусели
                const carousel = productCard.querySelector('.product-image-carousel');
                if (carousel) {
                    // Главное изображение
                    const mainImg = carousel.querySelector('.product-img');
                    if (mainImg && timestampedPaths[0]) {
                        mainImg.src = timestampedPaths[0];
                    }
                    
                    // Индикаторы карусели
                    const indicatorsContainer = carousel.querySelector('.image-indicators');
                    indicatorsContainer.innerHTML = timestampedPaths.map((_, index) => 
                        `<span class="indicator ${index === 0 ? 'active' : ''}" data-index="${index}"></span>`
                    ).join('');
                    
                    // Сохранить пути для changeImage функции
                    window[`${productId}-${selectedColor}`] = timestampedPaths;
                } else {
                    // Одиночное изображение
                    const singleImage = productCard.querySelector('img.product-img');
                    if (singleImage && timestampedPaths[0]) {
                        singleImage.src = timestampedPaths[0];
                    }
                }
                
                console.log(`✅ Обновлены изображения для ${brandModel} цвета ${selectedColor} (${imageData.image_count} фото из ${imageData.folder_name})`);
                
            } catch (error) {
                console.error(`❌ Ошибка загрузки изображений для ${brandModel} цвета ${selectedColor}:`, error);
                
                // Fallback - используем изображение из product.image_url если есть
                console.log('📸 Устанавливаем fallback изображение из product.image_url:', product.image_url);
                const fallbackImage = product.image_url || `/static/images/products/placeholder.jpg?v=${Date.now()}`;
                const carousel = productCard.querySelector('.product-image-carousel');
                if (carousel) {
                    const mainImg = carousel.querySelector('.product-img');
                    if (mainImg) {
                        mainImg.src = fallbackImage;
                    }
                }
            }
        }
        
        // Initialize variant buttons event listeners
        function initVariantButtons() {
            document.addEventListener('click', function(event) {
                if (event.target.classList.contains('variant-btn')) {
                    event.preventDefault();
                    event.stopPropagation();
                    
                    const buttonElement = event.target;
                    const productId = buttonElement.closest('.product-variants').dataset.productId;
                    
                    toggleVariant(productId, buttonElement);
                }
            });
        }
        
        // Call initVariantButtons when page loads
        initVariantButtons();
        
        // Function to get CSS color based on color name
        function getColorStyle(colorName) {
            if (!colorName || colorName === 'Default' || colorName === 'Не указан') {
                return '#E9ECEF'; // Дефолтный серый цвет
            }
            
            const colorMap = {
                // iPhone colors
                'ultramarine': '#a4b6f6', // Ультрамариновый
                'black': '#000000', 'white': '#FFFFFF', 'pink': '#FFB6C1', // Светло розовый
                'titanium-black': '#000000', // Чисто черный
                'titanium-white': '#FFFFFF', 'titanium-natural': '#979792', 'titanium-desert': '#B89569',
                'deep-blue': '#1B2951', 'cosmic-orange': '#FF6B35', 'silver': '#E8E8E8', // Светло серебристый
                'teal': '#20B2AA', // Бирюзовый
                
                // MacBook colors
                'space-gray': '#7F7F7F', 'silver': '#C0C0C0',
                
                // iPad colors
                'black': '#000000', 'blue': '#2563EB',
                
                // Other common colors
                'gray': '#6B7280', 'grey': '#6B7280', 'green': '#059669',
                'purple': '#7C3AED', 'gold': '#F59E0B', 'red': '#DC2626', 'orange': '#EA580C'
            };
            
            // Проверяем точное совпадение
            if (colorMap[colorName.toLowerCase()]) {
                return colorMap[colorName.toLowerCase()];
            }
            
            // Проверяем частичное совпадение (для составных цветов как "titanium-black")
            for (const [key, color] of Object.entries(colorMap)) {
                if (colorName.toLowerCase().includes(key)) {
                    return color;
                }
            }
            
            return '#6B7280'; // Цвет по умолчанию (серый)
        }
        
        // Function to determine text color based on background color
        function getTextColor(backgroundColor) {
            // Конвертируем hex в RGB
            const hex = backgroundColor.slice(1);
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Вычисляем яркость
            const brightness = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            
            return brightness > 128 ? '#000000' : '#FFFFFF';
        }
        
        // Function to get English label for color
        function getColorLabel(colorName) {
            if (!colorName || colorName === 'Default' || colorName === 'Не указан') {
                return 'Default';
            }
            
            const colorLabels = {
                'ultramarine': 'Ultramarine',
                'black': 'Black',
                'white': 'White',
                'pink': 'Pink',
                'yellow': 'Yellow',
                'teal': 'Teal',
                'titanium-black': 'Titanium Black',
                'titanium-white': 'Titanium White',
                'titanium-natural': 'Titanium Natural',
                'titanium-desert': 'Titanium Desert',
                'deep-blue': 'Deep Blue',
                'cosmic-orange': 'Cosmic Orange',
                'silver': 'Silver',
                'space-gray': 'Space Gray',
                'blue': 'Blue',
                'gray': 'Gray',
                'grey': 'Grey',
                'green': 'Green',
                'purple': 'Purple',
                'gold': 'Gold',
                'red': 'Red',
                'orange': 'Orange'
            };
            
            return colorLabels[colorName.toLowerCase()] || colorName;
        }
        
        // Initialize variants and colors for all cards
        async function initializeDefaultColors() {
            // Загрузить варианты для всех товаров через новый API
            for (const card of document.querySelectorAll('.product-card')) {
                const variantsElement = card.querySelector('[data-model]');
                if (variantsElement) {
                    const model = variantsElement.dataset.model;
                    try {
                        // Загрузить варианты через новый API
                        await loadVariantsForModel(card, model);
                    } catch (error) {
                        console.warn('Ошибка загрузки вариантов для модели:', model, error);
                    }
                }
            }
        }
        
        // Новая функция для загрузки вариантов модели
        async function loadVariantsForModel(productCard, model) {
            console.log('🔄 Загружаем варианты для модели:', model);
            
            const variantsElement = productCard.querySelector('.product-variants');
            if (!variantsElement) return;
            
            try {
                const response = await fetch(`/products/${encodeURIComponent(model)}/variants`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                console.log('✅ Загружены варианты:', data);
                
                // Очищаем элемент вариантов
                variantsElement.innerHTML = '';
                
                if (data.variants && data.variants.length > 0) {
                    // Группируем варианты по цветам
                    const colorGroups = {};
                    
                    data.variants.forEach(variant => {
                        const color = variant.color && variant.color.trim() !== '' ? variant.color : null;
                        if (color) { // Только добавляем варианты с реальными цветами
                            if (!colorGroups[color]) {
                                colorGroups[color] = [];
                            }
                            colorGroups[color].push(variant);
                        }
                    });
                    
                    console.log('🎨 Группы цветов:', Object.keys(colorGroups));
                    
                    // Создаем красивые цветные кнопки цветов
                    const colorButtons = Object.keys(colorGroups).map(color => {
                        const variants = colorGroups[color];
                        const activeClass = Object.keys(colorGroups).indexOf(color) === 0 ? 'active' : '';
                        
                        // Создаем красивую цветную кнопку
                        const colorStyle = getColorStyle(color);
                        const label = getColorLabel(color);
                        const textColor = getTextColor(colorStyle);
                        
                        return `
                            <button class="variant-btn color-btn ${activeClass}" 
                                    data-color="${color}" 
                                    data-model="${model}"
                                    data-type="color"
                                    style="background-color: ${colorStyle}; color: ${textColor}; border-color: ${colorStyle};">
                                ${label}
                            </button>
                        `;
                    }).join('');
                    
                    // Создаем красивые кнопки памяти (только с реальными значениями)
                    const memoryOptions = [...new Set(data.variants
                        .map(v => v.memory)
                        .filter(memory => memory && memory.trim() !== ''))];
                    const memoryButtons = memoryOptions.map((memory, index) => {
                        const activeClass = index === 0 ? 'active' : '';
                        return `
                            <button class="variant-btn memory-btn ${activeClass}" 
                                    data-memory="${memory}" 
                                    data-model="${model}"
                                    data-type="memory">
                                ${memory}
                            </button>
                        `;
                    }).join('');
                    
                    // Создаем красивые кнопки SIM (только с реальными значениями)
                    const simOptions = [...new Set(data.variants
                        .map(v => v.sim_type)
                        .filter(sim => sim && sim.trim() !== ''))];
                    // Маппинг для отображения типов SIM
                    const simLabels = {
                        'Single SIM': 'SIM + eSIM',
                        'eSIM': 'Dual eSIM',
                        'Dual SIM': 'Dual SIM'
                    };
                    
                    const simButtons = simOptions.map((sim, index) => {
                        const activeClass = index === 0 ? 'active' : '';
                        const displayLabel = simLabels[sim] || sim;
                        return `
                            <button class="variant-btn sim-btn ${activeClass}" 
                                    data-sim="${sim}" 
                                    data-model="${model}"
                                    data-type="sim">
                                ${displayLabel}
                            </button>
                        `;
                    }).join('');
                    
                    // Создаем HTML только для элементов с вариантами
                    let htmlContent = '';
                    
                    if (colorButtons) {
                        htmlContent += `
                            <div class="variant-group color-group">
                                <label>Цвет:</label>
                                <div class="variant-buttons">
                                    ${colorButtons}
                                </div>
                            </div>
                        `;
                    }
                    
                    if (memoryButtons) {
                        htmlContent += `
                            <div class="variant-group memory-group">
                                <label>Память:</label>
                                <div class="variant-buttons">
                                    ${memoryButtons}
                                </div>
                            </div>
                        `;
                    }
                    
                    if (simButtons) {
                        htmlContent += `
                            <div class="variant-group sim-group">
                                <label>СИМ:</label>
                                <div class="variant-buttons">
                                    ${simButtons}
                                </div>
                            </div>
                        `;
                    }
                    
                    
                    variantsElement.innerHTML = htmlContent;
                    
                    // Добавляем обработчики событий для новых кнопок
                    addVariantEventListeners(model, colorGroups);
                    
                    // Обновляем цену для первого варианта
                    updateVariantPrice(model, colorGroups);
                    
                } else {
                    variantsElement.innerHTML = '<div class="no-variants">Варианты не найдены</div>';
                }
                
                    } catch (error) {
                console.error('Ошибка загрузки вариантов:', error);
                variantsElement.innerHTML = '<div class="error">Ошибка загрузки вариантов</div>';
            }
        }
        
        // Функция для добавления обработчиков событий
        function addVariantEventListeners(model, colorGroups) {
            // Обработчик изменения цвета
            document.querySelectorAll(`[data-model="${model}"][data-type="color"]`).forEach(button => {
                button.addEventListener('click', function() {
                    // Убираем активный класс с других кнопок цвета
                    document.querySelectorAll(`[data-model="${model}"][data-type="color"]`).forEach(btn => btn.classList.remove('active'));
                    // Добавляем активный класс к нажатой кнопке
                    this.classList.add('active');
                    
                    // Обновляем цену при изменении варианта
                    updateVariantPrice(model, colorGroups);
                    
                    // Дополнительное обновление изображений для цвета
                    const selectedColor = this.dataset.color;
                    const productCard = this.closest('.product-card');
                    if (productCard) {
                        // Получаем product-id из карточки
                        const productIdMatch = productCard.outerHTML.match(/data-product-id="(\d+)"/);
                        if (productIdMatch) {
                            const productId = productIdMatch[1];
                            updateProductImage(productId, selectedColor);
                        }
                    }
                });
            });
            
            // Обработчик изменения памяти
            document.querySelectorAll(`[data-model="${model}"][data-type="memory"]`).forEach(button => {
                button.addEventListener('click', function() {
                    // Убираем активный класс с других кнопок памяти
                    document.querySelectorAll(`[data-model="${model}"][data-type="memory"]`).forEach(btn => btn.classList.remove('active'));
                    // Добавляем активный класс к нажатой кнопке
                    this.classList.add('active');
                    
                    // Обновляем цену при изменении варианта
                    updateVariantPrice(model, colorGroups);
                });
            });
            
            // Обработчик изменения SIM
            document.querySelectorAll(`[data-model="${model}"][data-type="sim"]`).forEach(button => {
                button.addEventListener('click', function() {
                    // Убираем активный класс с других кнопок SIM
                    document.querySelectorAll(`[data-model="${model}"][data-type="sim"]`).forEach(btn => btn.classList.remove('active'));
                    // Добавляем активный класс к нажатой кнопке
                    this.classList.add('active');
                    
                    // Обновляем цену при изменении варианта
                    updateVariantPrice(model, colorGroups);
                });
            });
        }
        
        // Функция для обновления цены выбранного варианта
        function updateVariantPrice(model, colorGroups) {
            const activeColorButton = document.querySelector(`[data-model="${model}"][data-type="color"].active`);
            const activeMemoryButton = document.querySelector(`[data-model="${model}"][data-type="memory"].active`);
            const activeSimButton = document.querySelector(`[data-model="${model}"][data-type="sim"].active`);
            
            if (!activeColorButton || !activeMemoryButton || !activeSimButton) return;
            
            const selectedColor = activeColorButton.dataset.color;
            const selectedMemory = activeMemoryButton.dataset.memory;
            const selectedSim = activeSimButton.dataset.sim;
            
            // Находим соответствующий вариант
            const variants = colorGroups[selectedColor] || [];
            const matchedVariant = variants.find(v => 
                v.memory === selectedMemory && v.sim_type === selectedSim
            );
            
            // Если точное соответствие не найдено, берем первый доступный вариант этого цвета
            const fallbackVariant = matchedVariant || variants[0];
            
            if (fallbackVariant) {
                // Обновляем основную цену в карточке товара
                const productCard = document.querySelector(`[data-model="${model}"]`).closest('.product-card');
                const currentPriceElement = productCard.querySelector('.current-price');
                
                if (currentPriceElement) {
                    const price = Math.round(fallbackVariant.price).toLocaleString();
                    currentPriceElement.textContent = `${price} ₽`;
                }
                
                console.log('💱 Обновлена цена:', fallbackVariant.price, '₽');
                
                if (!matchedVariant) {
                    console.log('ℹ️ Использован первый доступный вариант для цвета:', selectedColor);
                }
                
                // Обновляем изображения для выбранного цвета если они есть
                if (fallbackVariant.images && fallbackVariant.images.length > 0) {
                    const productCard = document.querySelector(`[data-model="${model}"]`).closest('.product-card');
                    if (productCard) {
                        const carousel = productCard.querySelector('.product-image-carousel');
                        if (carousel) {
                            const mainImg = carousel.querySelector('.product-img');
                            if (mainImg) {
                                mainImg.src = fallbackVariant.images[0] + `?v=${Date.now()}`;
                                console.log('🖼️ Обновлено изображение для цвета:', selectedColor);
                            }
                        }
                    }
                }
            } else {
                console.warn('❌ Вариант не найден:', {selectedColor, selectedMemory, selectedSim});
            }
        }
        
        async function createColorButtonsForProduct(productCard, productId) {
            console.log('🎨 Начинаем создание кнопок цветов для товара', productId);
            
            // Получить модель товара из data-model атрибута
            const variantsElement = productCard.querySelector('.product-variants');
            if (!variantsElement || !variantsElement.dataset.model) {
                console.log('❌ Элемент с моделью не найден');
                return;
            }
            
            const brandModel = variantsElement.dataset.model; // "Apple iPhone 16 Pro"
            console.log('📱 Найдена модель:', brandModel);
            
            // Получить цветовую схему из API с полной информацией о цветах
            const modelKey = getModelKey(brandModel);
            console.log('🔑 Определен ключ модели:', modelKey);
            let colorsData = [];

            if (modelKey) {
                try {
                    const response = await fetch(`/color-schemes/${modelKey}`);
                    if (response.ok) {
                        const data = await response.json();
                        // Извлекаем поля value из объектов цветов
                        colorsData = data.colors.map(color => color.value);
                        console.log('✅ Загружены цвета:', colorsData);
                        console.log('🧪 Тест извлечения цвета:', colorsData[0], typeof colorsData[0]);
                    } else {
                        console.warn(`Цветовая схема не найдена для ${modelKey}`);
                    }
                } catch (error) {
                    console.warn('Ошибка получения цветовой схемы:', error);
                }
            }

            // Если не удалось получить цвета из API, использовать fallback
            if (colorsData.length === 0) {
                colorsData = ['black'];
            }

            // Найти контейнер кнопок цветов
            const variantGroups = productCard.querySelectorAll('.variant-group');
            let colorContainer = null;
            for (const group of variantGroups) {
                const label = group.querySelector('label');
                if (label && label.textContent === 'Цвет:') {
                    colorContainer = group.querySelector('.variant-buttons');
                    break;
                }
            }
            if (!colorContainer) {
                console.log('❌ Контейнер цветов не найден');
                return;
            }
            
            console.log('🎨 Найден контейнер цветов, данные цветов:', colorsData);
            
            // Тестируем функции на известных цветах
            console.log('🧪 Тестирование функций цветов:');
            console.log('titanium-black ->', getColorStyle('titanium-black'));
            console.log('black ->', getColorStyle('black'));
            console.log('white ->', getColorStyle('white'));
            console.log('deep-blue ->', getColorStyle('deep-blue'));
            
            // Создать HTML и добавить цветные стили к кнопкам цветов
            const colorButtonsHTML = colorsData.map((colorValue, index) => {
                const isActive = index === 0 ? 'active' : '';
                
                // Убедимся что colorValue - это строка, а не объект
                const actualColorValue = typeof colorValue === 'string' ? colorValue : colorValue.value || colorValue.toString();
                console.log(`🎨 Обрабатываем цвет ${index}:`, { colorValue, actualColorValue, type: typeof colorValue });
                
                // Преобразовать название цвета в папку: "titanium-black" -> "titanium-black"
                const folderName = actualColorValue.toLowerCase().replace(/\s+/g, '_');
                const colorStyle = getColorStyle(actualColorValue);
                const label = getColorLabel(actualColorValue);
                const textColor = getTextColor(colorStyle);
                
                console.log(`🎨 Создаю кнопку для цвета ${actualColorValue}:`, { colorStyle, label, textColor });
                
                return `<button class="variant-btn color-btn ${isActive}" data-type="color" data-value="${actualColorValue}" data-color-folder="${folderName}" style="background-color: ${colorStyle}; color: ${textColor}; border-color: ${colorStyle};">${label}</button>`;
            }).join('');
            
            console.log('🎨 Создан HTML кнопок:', colorButtonsHTML);
            
            // Заменить содержимое контейнера
            colorContainer.innerHTML = colorButtonsHTML;
            console.log('✅ Цветовые кнопки заменены успешно');
            
            // Переиниторизовать обработчики событий
            initVariantButtons(productCard.querySelector('.product-variants'));
        }
        
        async function createVariantsForProduct(productCard, productId) {
            // Получить модель товара из data-model атрибута
            const variantsElement = productCard.querySelector('.product-variants');
            if (!variantsElement || !variantsElement.dataset.model) return;
            
            const brandModel = variantsElement.dataset.model; // "Apple iPhone 16 Pro"
            
            // Получить схему вариантов из API
            const modelKey = getModelKey(brandModel);
            let variantsData = {};
            
            if (modelKey) {
                try {
                    const response = await fetch(`/variant-schemes/${modelKey}`);
                    if (response.ok) {
                        const data = await response.json();
                        variantsData = data.variants;
                    } else {
                        console.warn(`Схема вариантов не найдена для ${modelKey}`);
                    }
                } catch (error) {
                    console.warn('Ошибка получения схемы вариантов:', error);
                }
            }
            
            // Найти контейнер вариантов
            const variantsContainer = productCard.querySelector('.product-variants');
            if (!variantsContainer) return;
            
            // Если нет вариантов из API, создать базовый набор
            if (Object.keys(variantsData).length === 0) {
                variantsData = {
                    color: ["Black"],
                    capacity: ["128GB"]
                };
            }
            
            // Создать HTML для всех вариантов
            let variantsHtml = '';
            
            // Обработать каждый тип варианта
            for (const [variantType, options] of Object.entries(variantsData)) {
                if (variantType === 'color' && (options === 'dynamic' || Array.isArray(options))) {
                    // Для цветов используем динамическую загрузку из color schemes
                    variantsHtml += `
                        <div class="variant-group">
                            <label>Цвет:</label>
                            <div class="variant-buttons">
                                <!-- Цвета будут загружены через createColorButtonsForProduct -->
                                <div class="loading">Загрузка цветов...</div>
                            </div>
                        </div>
                    `;
                    continue;
                }
                
                // Определить метку для типа варианта
                const labels = {
                    memory: 'Память',
                    sim: 'SIM',
                    screen: 'Диагональ',
                    ram: 'RAM',
                    ssd: 'SSD',
                    color: 'Цвет',
                    capacity: 'Объем'
                };
                
                const label = labels[variantType] || variantType;
                
                // Создать кнопки для опций
                const buttons = Array.isArray(options) ? options : [];
                const buttonsHtml = buttons.map((option, index) => {
                    const isActive = index === 0 ? 'active' : '';
                    const dataAttr = variantType === 'color' ? `data-color-folder="${option.toLowerCase()}"` : '';
                    return `<button class="variant-btn ${isActive}" data-type="${variantType}" data-value="${option}" ${dataAttr}>${option}</button>`;
                }).join('');
                
                variantsHtml += `
                    <div class="variant-group">
                        <label>${label}:</label>
                        <div class="variant-buttons">${buttonsHtml}</div>
                    </div>
                `;
            }
            
            // Заменить содержимое контейнера
            variantsContainer.innerHTML = variantsHtml;
            
            // Переинициализировать обработчики событий
            initVariantButtons(variantsContainer);
            
            // Здесь также нужно создать кнопки цветов если это цветовой тип
            // Проверяем есть ли цветовые варианты (массив или 'dynamic')
            if (variantsData.color && (Array.isArray(variantsData.color) || variantsData.color === 'dynamic')) {
                await createColorButtonsForProduct(productCard, productId);
            }
        }
        
        function getModelKey(brandModel) {
            // Преобразовать название модели в model_key (формат для API)
            console.log('🔍 Определяем model_key для:', brandModel);
            
            if (brandModel.includes('16 Pro Max')) return 'IPHONE16ProMax';
            if (brandModel.includes('16 Pro')) return 'IPHONE16Pro';
            if (brandModel.includes('17 Pro Max')) return 'IPHONE17ProMax';
            if (brandModel.includes('17 Pro')) return 'IPHONE17Pro';
            if (brandModel.includes('16')) return 'IPHONE16';
            if (brandModel.includes('17')) return 'IPHONE17';
            if (brandModel.includes('MacBook Air M2')) return 'MACBOOKAirM2';
            if (brandModel.includes('iPad Air')) return 'IPADAir';
            if (brandModel.includes('AirPods Pro 2')) return 'AIRPODSPro2';
            if (brandModel.includes('HomePod mini')) return 'HOMEPODmini';
            
            console.warn('⚠️ Не удалось определить model_key для:', brandModel);
            return null; // Модель не найдена
        }
        
        

        async function getDefaultColorForProduct(productCard) {
            // Получить модель товара из data-model атрибута
            const variantsElement = productCard.querySelector('.product-variants');
            if (!variantsElement || !variantsElement.dataset.model) return 'Black';
            
            const brandModel = variantsElement.dataset.model;
            
            const modelKey = getModelKey(brandModel);
            if (!modelKey) {
                return 'Black'; // Fallback цвет
            }
            
            try {
                const response = await fetch(`/color-schemes/${modelKey}`);
                if (response.ok) {
                    const data = await response.json();
                    return data.default_color || 'Black';
                }
            } catch (error) {
                console.warn('Ошибка получения цветовой схемы:', error);
            }
            
            return 'Black'; // Fallback цвет
        }
        
        // Show product details
        async function showProductDetails(productId) {
            try {
                showLoading();
                const response = await fetch(`${API_BASE}/products/${productId}`);
                const product = await response.json();
                
                // Получить полное описание из характеристик
                let fullDescription = product.description;
                if (product.specifications && product.specifications.full_description) {
                    fullDescription = product.specifications.full_description;
                }
                
                // Создать HTML для детального просмотра
                const detailsHtml = `
                    <button class="back-button" onclick="loadProducts(${currentCategoryId || 1})">← Назад к товарам</button>
                    <div class="product-details">
                        <div class="product-details-header">
                            <div class="product-details-image">
                                ${product.images && product.images.length > 0 ? 
                                    `<img src="${product.images[0]}" alt="${product.name}" class="details-img">` :
                                    `<div class="details-placeholder">📱</div>`
                                }
                            </div>
                            <div class="product-details-info">
                                <h1 class="product-details-name">${product.name}</h1>
                                <div class="product-details-brand">${product.brand} ${product.model}</div>
                                <div class="product-details-price">
                                    <span class="current-price">${Math.round(product.price).toLocaleString()} ₽</span>
                                    ${product.old_price > product.price ? 
                                        `<span class="old-price">${Math.round(product.old_price).toLocaleString()} ₽</span>` : ''
                                    }
                                    ${product.discount_percentage > 0 ? 
                                        `<span class="discount">-${Math.round(product.discount_percentage)}%</span>` : ''
                                    }
                                </div>
                                <div class="product-details-sku">SKU: ${product.sku}</div>
                            </div>
                        </div>
                        
                        <div class="product-details-content">
                            <div class="product-description-section">
                                <h3>📝 Описание</h3>
                                <div class="product-full-description">${fullDescription.replace(/\n/g, '<br>')}</div>
                            </div>
                            
                            ${product.specifications ? `
                                <div class="product-specifications-section">
                                    <h3>⚙️ Характеристики</h3>
                                    <div class="specifications-grid">
                                        ${Object.entries(product.specifications)
                                            .filter(([key, value]) => !['full_description', 'variants', 'images', 'image_folder', 'memories', 'colors', 'sim_types', 'цвета'].includes(key))
                                            .map(([category, details]) => `
                                                <div class="spec-category">
                                                    <h4>${category.charAt(0).toUpperCase() + category.slice(1)}</h4>
                                                    ${typeof details === 'object' ? 
                                                        Object.entries(details).map(([key, value]) => 
                                                            `<div class="spec-item">
                                                                <span class="spec-key">${key.replace(/_/g, ' ')}:</span>
                                                                <span class="spec-value">${Array.isArray(value) ? value.join(', ') : value}</span>
                                                            </div>`
                                                        ).join('') :
                                                        `<div class="spec-item">${details}</div>`
                                                    }
                                                </div>
                                            `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                            
                            <div class="product-actions">
                                <button class="buy-button" onclick="alert('Функция покупки будет добавлена позже')">
                                    🛒 Купить
                                </button>
                                <button class="favorite-button" onclick="alert('Функция избранного будет добавлена позже')">
                                    ❤️ В избранное
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.getElementById('content').innerHTML = detailsHtml;
                
            } catch (error) {
                showError('Ошибка загрузки деталей товара');
            }
        }
        
        // Управление каруселью изображений
        const productImages = {}; // Хранилище изображений для каждого товара
        
        function changeImage(productId, direction) {
            console.log('changeImage called:', productId, direction);
            const carousel = document.querySelector(`[data-product-id="${productId}"]`);
            if (!carousel) {
                console.log('Carousel not found for product:', productId);
                return;
            }
            
            // Найти карточку товара для определения текущего цвета
            const productCard = carousel.closest('.product-card');
            const variantsContainer = productCard?.querySelector('.product-variants');
            const activeColorButton = variantsContainer?.querySelector('.variant-btn[data-type="color"].active');
            
            let selectedColor = 'Black'; // По умолчанию черный
            
            if (activeColorButton) {
                selectedColor = activeColorButton.dataset.colorFolder || activeColorButton.dataset.value || activeColorButton.dataset.color || 'Black';
            }
            
            // Проверяем что selectedColor не undefined
            if (!selectedColor || selectedColor === 'undefined') {
                selectedColor = 'Black';
            }
            
            // Создать ключ для конкретного цвета и получить изображения
            const colorImagesKey = `${productId}-${selectedColor}`;
            
            if (!window[colorImagesKey]) {
                // Если изображения для этого цвета не загружены, создать их динамически
            
            const modelElement = productCard?.querySelector('.product-brand');
            const brandModel = modelElement?.textContent?.trim() || '';
            
            let modelFolder = 'IPHONE16'; // Дефолтная папка
            
            // Определяем папку изображений на основе модели
            if (brandModel.includes('16 Pro Max')) {
                modelFolder = 'IPHONE16ProMax';
            } else if (brandModel.includes('16 Pro')) {
                modelFolder = 'IPHONE16Pro';
            } else if (brandModel.includes('16')) {
                modelFolder = 'IPHONE16';
            } else if (brandModel.includes('17 Pro Max')) {
                modelFolder = 'IPHONE17ProMax';
            } else if (brandModel.includes('17')) {
                modelFolder = 'IPHONE17';
            } else if (brandModel.includes('AirPods Pro 2')) {
                modelFolder = 'AIRPODSPro2';
            } else if (brandModel.includes('HomePod mini')) {
                modelFolder = 'HOMEPODmini';
            } else if (brandModel.includes('iPad Air')) {
                modelFolder = 'IPADAir';
            }
            
            // Создаем список изображений только с ожидаемым количеством
            const colorImageList = [];
            
            // Определяем ожидаемое количество изображений для каждого цвета
            let expectedImageCount = 4; // По умолчанию 4 изображения
            
            // Специальные правила для разных цветов моделей
            if (selectedColor === 'White' && modelFolder === 'IPHONE16') {
                expectedImageCount = 3; // iPhone 16 White имеет только 3 изображения
            } else if (selectedColor === 'Silver' && modelFolder === 'IPHONE17ProMax') {
                expectedImageCount = 3; // iPhone 17 Pro Max Silver имеет 3 изображения
            } else if (selectedColor === 'Deep Blue' && modelFolder === 'IPHONE17ProMax') {
                expectedImageCount = 3; // iPhone 17 Pro Max Deep Blue имеет 3 изображения
            }
            
            // Сопоставление цветов из базы данных с названиями папок
            const colorFolderMapping = {
                'Teal': 'teal',
                'Pink': 'pink', 
                'White': 'white',
                'Black': 'black',
                'Default': 'black', // Дефолтный цвет
                'Titanium White': 'titanium-white',
                'Titanium Blue': 'titanium-blue', 
                'Titanium Natural': 'titanium-natural',
                'Titanium Black': 'titanium-black',
                'Titanium Desert': 'titanium-desert',
                'Space Black': 'space-black',
                'Silver': 'silver',
                'Deep Blue': 'deep-blue',
                'Cosmic Orange': 'cosmic-orange'
            };
            
            // Получаем правильное название папки для цвета
            const colorFolder = colorFolderMapping[selectedColor] || selectedColor.toLowerCase();
            
            // Сначала проверим есть ли уже изображения в cache от updateProductImage
            let cachedImages = window[colorImagesKey];
            if (cachedImages && cachedImages.length > 0) {
                console.log(`📸 Используем изображения из cache для ${selectedColor}:`, cachedImages);
                colorImageList = cachedImages;
            } else {
                // Если нет cached изображений, запрашиваем из API
                console.log('📸 Получаем изображения из API...');
                
                let modelKey = 'IPHONE16ProMax'; // Дефолтная папка
                if (brandModel.includes('16 Pro Max')) {
                    modelKey = 'IPHONE16ProMax';
                } else if (brandModel.includes('17 Pro Max')) {
                    modelKey = 'IPHONE17ProMax';
                }
                
                fetch(`/product-images/${modelKey}/${colorFolder}`)
                    .then(response => response.json())
                    .then(data => {
                        const timestampedImages = data.image_paths.map(img => `${img}?v=${Date.now()}`);
                        window[colorImagesKey] = timestampedImages;
                        console.log(`📸 Получены изображения из API для ${selectedColor}:`, timestampedImages);
                    })
                    .catch(error => {
                        console.error(`❌ Ошибка получения изображений для ${selectedColor}:`, error);
                        // Fallback на статические пути только если API недоступно
                        for (let i = 1; i <= expectedImageCount; i++) {
                            colorImageList.push(`/static/images/products/${modelFolder}/${colorFolder}/${i}.jpg`);
                        }
            const timestampedImages = colorImageList.map(img => `${img}?v=${Date.now()}`);
            window[colorImagesKey] = timestampedImages;
                    });
            }
            }
            
            const indicators = carousel.querySelectorAll('.indicator');
            const currentActive = carousel.querySelector('.indicator.active');
            const currentIndex = parseInt(currentActive.dataset.index);
            
            let newIndex = currentIndex + direction;
            
            // Циклическое переключение в пределах доступных изображений
            if (newIndex < 0) {
                newIndex = indicators.length - 1;
            } else if (newIndex >= indicators.length) {
                newIndex = 0;
            }
            
            // Дополнительная проверка: убедиться что для текущего цвета это изображение существует
            const currentColorImages = window[colorImagesKey];
            if (newIndex >= currentColorImages.length) {
                console.log(`Index ${newIndex} is out of range for color ${selectedColor} (only ${currentColorImages.length} images), adjusting...`);
                newIndex = Math.max(0, currentColorImages.length - 1); // перейти к последнему доступному изображению
            }
            
            console.log('Changing from index', currentIndex, 'to', newIndex);
            
            // Обновить активный индикатор
            currentActive.classList.remove('active');
            indicators[newIndex].classList.add('active');
            
            // Обновить изображение используя изображения текущего цвета
            const img = carousel.querySelector('.product-img');
            const activeColorImages = window[colorImagesKey];
            
            if (activeColorImages && activeColorImages[newIndex]) {
                console.log('Changing image to:', activeColorImages[newIndex], 'color:', selectedColor);
                img.src = activeColorImages[newIndex];
            } else {
                console.log('No image found for product:', productId, 'index:', newIndex, 'color:', selectedColor);
                console.log('Available color images:', activeColorImages);
                
                // Fallback: попробовать первое доступное изображение или изображение из дефолтного цвета
                const firstImage = activeColorImages && activeColorImages.length > 0 ? activeColorImages[0] : null;
                const defaultImages = window[`${productId}-Black`];
                const fallbackImage = firstImage || (defaultImages && defaultImages[0]);
                
                if (fallbackImage) {
                    console.log('Using fallback image:', fallbackImage);
                    img.src = fallbackImage;
                } else {
                    console.warn('No fallback image available for product:', productId);
                }
            }
        }
        
        // Функция для проверки существования изображений
        async function checkAndFilterImages(colorImages, timestampedImages) {
            const existingImages = [];
            
            for (let i = 0; i < colorImages.length; i++) {
                try {
                    // Попробуем загрузить изображение
                    await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(colorImages[i]);
                        img.onerror = () => reject(new Error('Image not found'));
                        img.src = colorImages[i];
                    });
                    existingImages.push(timestampedImages[i]);
                } catch (error) {
                    // Изображение не существует, пропускаем
                    console.log(`Image ${i+1} not found for this color, skipping`);
                    break; // Предполагаем что после первого отсутствующего все остальные тоже отсутствуют
                }
            }
            
            return existingImages;
        }
        
        // Сохранить изображения товара при загрузке
        function storeProductImages(product) {
            if (product.images && product.images.length > 0) {
                productImages[product.id] = product.images;
                console.log('Stored images for product', product.id, ':', product.images);
            } else {
                console.log('No images for product', product.id);
            }
        }
        
        // Show loading state
        function showLoading() {
            document.getElementById('content').innerHTML = '<div class="loading">Загрузка...</div>';
        }
        
        // Hide loading state - just clear loading indicator
        function hideLoading() {
            // Loading состояние должно очищаться автоматически когда контент обновляется
            // Эта функция служит как placeholder на случай если нужно явно скрыть loading
        }
        
        // Show error state
        function showError(message) {
            document.getElementById('content').innerHTML = `<div class="error">${message}</div>`;
        }
        
        // Telegram WebApp integration
        // Создание хлебных крошек навигации
        function createBreadcrumbs(brand = null) {
            let breadcrumbs = [];
            
            // Домашний уровень (категории)
            breadcrumbs.push(`
                <div class="breadcrumb-item">
                    <a href="javascript:void" class="breadcrumb-link" onclick="loadCategories()">Категории</a>
                </div>
            `);
            
            // Добавляем категорию (level0) - кликабельную
            if (currentLevel0Filter) {
                breadcrumbs.push(`
                    <span class="breadcrumb-separator">→</span>
                    <div class="breadcrumb-item">
                        <a href="javascript:void" class="breadcrumb-link" onclick="navigateToLevel0()">${currentLevel0Filter}</a>
                    </div>
                `);
            }
            
            // Добавляем бренд - кликабельный если есть level1 или level2
            if (brand) {
                const isClickable = currentLevel1Filter || currentLevel2Filter;
                if (isClickable) {
                    breadcrumbs.push(`
                        <span class="breadcrumb-separator">→</span>
                        <div class="breadcrumb-item">
                            <a href="javascript:void" class="breadcrumb-link" onclick="navigateToBrand('${brand}')">${brand}</a>
                        </div>
                    `);
                } else {
                    breadcrumbs.push(`
                        <span class="breadcrumb-separator">→</span>
                        <div class="breadcrumb-item">
                            <span class="breadcrumb-current">${brand}</span>
                        </div>
                    `);
                }
            }
            
            // Добавляем уровень 1 - кликабельный если есть level2
            if (currentLevel1Filter) {
                const isClickable = currentLevel2Filter !== null;
                if (isClickable) {
                    breadcrumbs.push(`
                        <span class="breadcrumb-separator">→</span>
                        <div class="breadcrumb-item">
                            <a href="javascript:void" class="breadcrumb-link" onclick="navigateToLevel1('${currentLevel1Filter}')">${currentLevel1Filter}</a>
                        </div>
                    `);
                } else {
                    breadcrumbs.push(`
                        <span class="breadcrumb-separator">→</span>
                        <div class="breadcrumb-item">
                            <span class="breadcrumb-current">${currentLevel1Filter}</span>
                        </div>
                    `);
                }
            }
            
            // Добавляем уровень 2 - всегда текущий (не кликабельный)
            if (currentLevel2Filter) {
                breadcrumbs.push(`
                    <span class="breadcrumb-separator">→</span>
                    <div class="breadcrumb-item">
                        <span class="breadcrumb-current">${currentLevel2Filter}</span>
                    </div>
                `);
            }
            
            return `
                <div class="breadcrumb-trail">
                    ${breadcrumbs.join('')}
                </div>
            `;
        }
        
        // Обновление хлебных крошек
        function updateBreadcrumbs() {
            const breadcrumbsContainer = document.getElementById('breadcrumbsContainer');
            if (breadcrumbsContainer) {
                breadcrumbsContainer.innerHTML = createBreadcrumbs(currentBrandFilter);
            }
        }
        
        // Навигация к уровню level0 (категории)
        async function navigateToLevel0() {
            if (currentCategoryId && currentCategoryName) {
                // Загружаем бренды текущей категории
                await loadSubcategories(currentCategoryId);
            } else {
                // Fallback: возвращаемся к главной странице категорий
                loadCategories();
            }
        }
        
        // Навигация к бренду (сброс level1 и level2)
        async function navigateToBrand(brand) {
            currentLevel1Filter = null;
            currentLevel2Filter = null;
            await loadFilteredProducts();
            updateBreadcrumbs();
            await createHierarchyFilters(currentBrandFilter, []);
        }
        
        // Навигация к level1 (сброс level2)
        async function navigateToLevel1(level1Value) {
            currentLevel1Filter = level1Value;
            currentLevel2Filter = null;
            await loadFilteredProducts();
            updateBreadcrumbs();
            await createHierarchyFilters(currentBrandFilter, []);
        }
        
        // Навигация к level2
        async function navigateToLevel2(level2Value) {
            currentLevel2Filter = level2Value;
            await loadFilteredProducts();
            updateBreadcrumbs();
            await createHierarchyFilters(currentBrandFilter, []);
        }

        if (window.Telegram && window.Telegram.WebApp) {
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.expand();
        }
    </script>
</body>
</html>

